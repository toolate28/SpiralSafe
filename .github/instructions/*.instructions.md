---
spiralsafe:
  status: active
  coherence_phase: learning
  last_verified: 2026-01-04
  atom_tags:
    - ATOM-DOC-20260104-004
  intent: "Enable agents to detect, analyze, and systematically eliminate anti-waves and coherence violations"
  depends_on:
    - 00-spiralsafe-coherence-engine.instructions.md
    - 01-verification-gate-protocol.instructions.md
---

# Anti-Wave Detection & Prevention

## How Agents Identify and Eliminate Coherence Violations

An **anti-wave** is a pattern where SpiralSafe's own coherence principles break down. This document teaches agents to recognize, analyze, and systematically eliminate anti-waves.

---

## Understanding Anti-Waves

### What Is an Anti-Wave?

An anti-wave is **not a bug or error**. It's a structural pattern where the system's own principles fail to maintain coherence.

**Example Anti-Wave:** "Bedrock Illusion"
- **Principle:** Decisions should be verified before archival
- **Anti-Wave:** Decisions archive based on age, not validity
- **Result:** Bad decisions ossify into "trusted" bedrock
- **Root:** Missing verification gate at archive boundary

### Why Anti-Waves Matter

1. **They're invisible to external analysis.** You can't detect them by looking at other systems.
2. **They're proof the methodology works.** When wave.md excavates SpiralSafe itself, it finds exactly what it finds in other systems: architectural fractures.
3. **Fixing them strengthens the framework.** Each anti-wave resolved makes SpiralSafe itself coherent.

---

## The Five Canonical Anti-Waves

### Anti-Wave #1: Bedrock Illusion

**The Problem:**
```
Assumption: Archived decisions are stable and trustworthy
Reality: Decisions age without validity checking
Result: Bad decisions become "trusted bedrock"
```

**Detection Checklist:**
- [ ] Decisions archived based on age only
- [ ] No re-excavation required for bedrock
- [ ] No verification that archived decision is still valid
- [ ] Age = 180+ days = "stable" (regardless of truth)

**Detection Signal:** When you see archived decisions never questioned again.

**Systematic Fix:**
1. Add verification gate at archival boundary
2. Require validity check before migration to bedrock
3. Implement re-excavation protocol for aging decisions
4. Track decision age separately from decision validity

**Verification After Fix:**
```bash
# Before: archive based on age
AGE >= 180 days → BEDROCK ✗

# After: archive only if valid AND aged
(AGE >= 180 days) AND (validity_verified) → BEDROCK ✓
```

**Example Implementation:**
```yaml
---
bedrock_migration_gate:
  requirement_1: "decision_age_meets_threshold: ≥180 days"
  requirement_2: "decision_still_valid: true"
  requirement_3: "validation_test_passes: true"
  requirement_4: "no_contradicting_evidence: true"
  
  if_any_fails: "escalate_to_human_review"
  log_to: "ATOM trail as re-excavation event"
---
```

---

### Anti-Wave #2: Context Orphaning

**The Problem:**
```
Assumption: bump.md provides shared state and mission alignment
Reality: bump.md is template with placeholder values
Result: Intent disconnects from execution
```

**Detection Checklist:**
- [ ] bump.md exists but isn't enforced
- [ ] No validation that bump.md is filled before work starts
- [ ] Agents don't inherit bump.md context
- [ ] Multiple workers can have conflicting bump.md states
- [ ] Intent metadata doesn't flow with execution

**Detection Signal:** When you see agents executing work without clear shared intention.

**Systematic Fix:**
1. Convert bump.md from template to locked protocol
2. Add CI validation requiring non-placeholder values
3. Enforce bump.md exists before agent execution
4. Make bump.md context available to all subtasks
5. Verify bump.md matches actual execution

**Verification After Fix:**
```bash
# Before: template exists but not enforced
bump.md exists → [placeholder values] → execute ✗

# After: protocol enforced with validation
bump.md required AND CI validates AND values non-placeholder → execute ✓
```

**Example Validation:**
```bash
#!/bin/bash
validate_bump_md() {
    local bump_file="$1"
    
    # Check file exists
    [ -f "$bump_file" ] || fail "bump.md required before execution"
    
    # Check required fields filled
    grep -q "^ATOM:" "$bump_file" || fail "ATOM tag required"
    grep -q "^Title:" "$bump_file" || fail "Title required"
    grep -q "^Author:" "$bump_file" || fail "Author required"
    
    # Check no placeholders
    grep -q "<\|>\|TODO\|FIXME\|placeholder" "$bump_file" && \
        fail "Placeholders found; fill before proceeding"
    
    # Check intention clear
    grep -q "Intention:" "$bump_file" || fail "Intention must be specified"
    [ "$(grep 'Intention:' "$bump_file" | wc -l)" -ge 1 ] || \
        fail "Intention section is empty"
    
    pass "bump.md valid and enforced"
}
```

---

### Anti-Wave #3: Framework Scatter Without Verification

**The Problem:**
```
Assumption: KENL ensures information improves through relay
Reality: Knowledge relays but enrichment isn't measured
Result: Pattern entropy; knowledge scatters into noise
```

**Detection Checklist:**
- [ ] KENL patterns described but not measured
- [ ] Knowledge relays but nobody verifies enrichment
- [ ] Patterns propagate but don't improve through relay
- [ ] No lineage tracking; origin and evolution hidden
- [ ] "Information enriches" is faith, not physics

**Detection Signal:** When you can't answer "Did this pattern improve when it relayed?"

**Systematic Fix:**
1. Add enrichment measurement to every relay
2. Track pattern before and after adaptation
3. Document improvement in ATOM trail
4. Require lineage documentation
5. Verify relay happened and measured

**Verification After Fix:**
```bash
# Before: relay assumed to improve
Pattern → Relay → Assumption of enrichment ✗

# After: relay measured and verified
Pattern → Relay (with measurement) → Enrichment verified ✓
```

**Example Measurement:**
```yaml
---
kenl_relay_measurement:
  pattern_id: "KENL-PATTERN-20260104-001"
  
  before_relay:
    applicability: "System A only"
    effectiveness: 75%
    constraints_handled: 3
  
  after_relay:
    applicability: "Systems A, B, C"
    effectiveness: 85%
    constraints_handled: 5
  
  enrichment_verified: true
  enrichment_evidence:
    - "Broader applicability"
    - "Higher effectiveness"
    - "More constraints handled"
  
  lineage_updated: "KENL-PATTERN-20260104-001-v2"
---
```

---

### Anti-Wave #4: CI/Workflow Islands

**The Problem:**
```
Assumption: GitHub workflows create integrated verification pipeline
Reality: Eight workflows exist but don't connect
Result: Verification gaps; CI passes ≠ ATOM compliance
```

**Detection Checklist:**
- [ ] Multiple workflows exist independently
- [ ] Workflows don't trigger each other
- [ ] Workflow success doesn't update ATOM trail
- [ ] ATOM compliance not verified in CI
- [ ] Freshness updates don't connect to workflows

**Detection Signal:** When you see workflows completing successfully but system coherence isn't updated.

**Systematic Fix:**
1. Connect workflows to ATOM trail
2. Each workflow creates ATOM decision
3. Workflows query ATOM for context
4. CI validates ATOM compliance
5. Freshness updates triggered by workflow events

**Verification After Fix:**
```bash
# Before: workflows isolated
workflow.yml → success → [nothing recorded]  ✗

# After: workflows connected
workflow.yml → success → ATOM_record → coherence_updated ✓
```

**Example Connection:**
```yaml
# .github/workflows/unified-pipeline.yml
name: Unified Coherence Verification

on: [push, pull_request]

jobs:
  spiral:
    runs-on: ubuntu-latest
    steps:
      # Step 1: Create ATOM record
      - name: Initialize ATOM Task
        run: |
          ATOM_ID=$(date +ATOM-WORKFLOW-%Y%m%d-%s)
          echo "ATOM_ID=$ATOM_ID" >> $GITHUB_ENV
          atom_record_phase_start "execution" "$ATOM_ID"
      
      # Step 2: Run verification gates
      - name: Verify Understanding Gate
        run: ./verify-gates.sh understanding "$ATOM_ID"
      
      - name: Verify Knowledge Gate
        run: ./verify-gates.sh knowledge "$ATOM_ID"
      
      - name: Verify Intention Gate
        run: ./verify-gates.sh intention "$ATOM_ID"
      
      # Step 3: Update ATOM trail
      - name: Record Success to ATOM Trail
        if: success()
        run: atom_record_phase_complete "execution" "$ATOM_ID"
      
      - name: Escalate on Failure
        if: failure()
        run: atom_record_gate_failure "ALL_GATES" "$ATOM_ID"
```

---

### Anti-Wave #5: Documentation Archaeology Problem

**The Problem:**
```
Assumption: Documentation is production-ready and verified
Reality: Active docs mixed with aspirational docs
Result: Reader confusion; confidence erosion
```

**Detection Checklist:**
- [ ] Documents don't have status markers
- [ ] Active mixed with aspirational
- [ ] Historical docs indistinguishable from current
- [ ] Readers can't tell what's implemented vs. planned
- [ ] No CI validation of document state

**Detection Signal:** When you see readers asking "Is this feature already built or planned?"

**Systematic Fix:**
1. Add status markers to all documents
2. Create CI validation for marker consistency
3. Build documentation dashboard
4. Distinguish active/aspirational/historical/archived
5. Link aspirational docs to tracking issues

**Verification After Fix:**
```bash
# Before: status unknown
# Is this implemented? [Have to guess]  ✗

# After: status explicit
# Document header shows: status: active  ✓
# Readers know immediately what they're reading
```

**Example State Marker:**
```yaml
---
spiralsafe:
  status: active                          # active | aspirational | historical | archived
  coherence_phase: execution              # which phase is this doc about?
  last_verified: 2026-01-04               # when was this verified?
  verification_method: automated          # how was it verified?
  atom_tags:
    - ATOM-DOC-20260104-001
  intent: "Clear statement of why this doc exists"
  dependencies:
    - other_doc: "relationship"
  verification_checklist:
    - feature_implemented: pass
    - documentation_current: pass
    - examples_tested: pass
---

# Document Title [status: active]

*This is the header every reader sees immediately.*
```

---

## Detection: How Agents Spot Anti-Waves

### Pattern 1: Boundary Without Gate

**Signal:** Work flowing across a phase boundary without verification

```bash
detect_boundary_without_gate() {
    # Check each phase transition for gate
    for boundary in \
        "understanding_to_knowledge" \
        "knowledge_to_intention" \
        "intention_to_execution" \
        "execution_to_learning" \
        "learning_to_understanding"
    do
        if ! gate_exists "$boundary"; then
            report_anti_wave "Missing gate at $boundary"
        fi
    done
}
```

**Action:** Create verification gate for that boundary

### Pattern 2: Assumption Without Validation

**Signal:** Work proceeding on implicit assumption

```bash
detect_assumption_without_validation() {
    # Assumptions in code/docs without tests
    if grep -r "assume\|assume" --include="*.md" --include="*.sh" .; then
        for line in $(grep -r "assum" .); do
            if ! grep -q "test.*${line}" .; then
                report_anti_wave "Assumption without validation: $line"
            fi
        done
    fi
}
```

**Action:** Create test validating assumption; make explicit in code

### Pattern 3: Knowledge Without Lineage

**Signal:** Patterns used but origin unknown

```bash
detect_knowledge_without_lineage() {
    # KENL patterns without lineage
    find . -name "*.pattern" -exec grep -L "received_from\|lineage" {} \;
    # Each result is anti-wave
}
```

**Action:** Document pattern lineage; track evolution

### Pattern 4: Execution Without Learning

**Signal:** Work completed but no analysis of what happened

```bash
detect_execution_without_learning() {
    # ATOM tasks without SAIF analysis
    find . -name "ATOM-TASK-*" -exec \
        [ -f "{}/learning.md" ] || \
        report_anti_wave "No learning extracted from {}" \;
}
```

**Action:** Extract learning before closing task; SAIF analysis required

### Pattern 5: Cycle Without Regeneration

**Signal:** Learning that doesn't feed future cycles

```bash
detect_cycle_without_regeneration() {
    # Learning documented but not connected to next cycle
    if [ -f "learning.md" ]; then
        if ! grep -q "next_cycle\|inform\|future\|excavation" learning.md; then
            report_anti_wave "Learning not connected to regeneration"
        fi
    fi
}
```

**Action:** Explicitly connect learning to next excavation

---

## Systematic Anti-Wave Prevention

### Prevention Matrix

| Anti-Wave | Prevented By | Triggered When | Escalation |
|-----------|--------------|----------------|------------|
| #1: Bedrock Illusion | Verification gate at archive boundary | Decisions aging without validation check | Re-excavate before archival |
| #2: Context Orphaning | bump.md enforced in CI | Execution without clear shared intent | Block execution; require bump.md |
| #3: Scatter Without Verification | Enrichment measurement on every relay | Knowledge propagates unmeasured | Measure relay or block propagation |
| #4: Workflow Islands | Workflows connected to ATOM trail | CI success without coherence update | Update workflow to record ATOM |
| #5: Documentation Archaeology | State markers + CI validation | Docs without status | Retroactively add markers |

### Prevention Automation

Create system-wide checks:

```bash
#!/bin/bash
# prevent-anti-waves.sh
# Run in CI to catch anti-waves before they propagate

# Check for Anti-Wave #1: Bedrock without validation
if [ -d ".atom-trail/bedrock" ]; then
    for decision in $(ls .atom-trail/bedrock); do
        if ! grep -q "verified_before_archive" "$decision"; then
            fail "Anti-Wave #1 detected: bedrock without validation gate"
        fi
    done
fi

# Check for Anti-Wave #2: Context orphaning
if [ -f "bump.md" ]; then
    if grep -q "<\|>\|TODO\|FIXME" bump.md; then
        fail "Anti-Wave #2 detected: bump.md has placeholders"
    fi
else
    fail "Anti-Wave #2 detected: bump.md required"
fi

# Check for Anti-Wave #3: Knowledge without lineage
for pattern in $(find . -name "*.pattern"); do
    if ! grep -q "lineage\|received_from" "$pattern"; then
        fail "Anti-Wave #3 detected: pattern without lineage"
    fi
done

# Check for Anti-Wave #4: Workflows not connected
if [ -d ".github/workflows" ]; then
    for workflow in $(ls .github/workflows); do
        if ! grep -q "ATOM\|atom_record" "$workflow"; then
            warn "Anti-Wave #4 potential: workflow not connected to ATOM trail"
        fi
    done
fi

# Check for Anti-Wave #5: Documentation without status
for doc in $(find . -name "*.md"); do
    if ! grep -q "status:" "$doc" 2>/dev/null; then
        warn "Anti-Wave #5 potential: $doc missing status marker"
    fi
done

echo "✓ Anti-wave prevention checks complete"
```

---

## Negative Space: The Sixth Anti-Wave

Beyond the five canonical anti-waves exists **negative space**—the gaps between frameworks where coherence can slip away invisibly.

### Types of Negative Space

#### Missing Connectors
```
Knowledge ──[explicit connector]──→ Intent
         ✗ (missing = negative space)
```

**What breaks:** Knowledge doesn't shape intent; disconnect accumulates

**How to fill:** Create explicit bridge with tests and documentation

#### Unmeasured Transitions
```
Execution ──[measurement point]──→ Learning
        ✗ (unmeasured = invisible)
```

**What breaks:** Success assumed without verification

**How to fill:** Add metrics at transition; make success visible

#### Unstated Assumptions
```
"We assume X is true"
    ↓
✗ (assumption not validated)
    ↓
System breaks when X is false
```

**What breaks:** System fragile to unstated assumption violations

**How to fill:** Create tests validating all assumptions; make explicit

### Negative Space Detection Protocol

```bash
detect_negative_space() {
    echo "Scanning for negative space..."
    
    # Check 1: Orphaned documents
    echo "- Orphaned documents (no ATOM tag)..."
    find . -name "*.md" ! -exec grep -l "atom_tag\|ATOM" {} \;
    
    # Check 2: Disconnected subsystems
    echo "- Subsystems not integrated with verification gates..."
    find . -type f -name "*.sh" ! -exec grep -l "verify_gate\|gate_" {} \;
    
    # Check 3: Decaying knowledge
    echo "- Patterns no longer referenced in code..."
    for pattern in $(find . -name "*.pattern"); do
        pattern_name=$(basename "$pattern")
        if ! grep -r "$pattern_name" --exclude="*.pattern" .; then
            echo "  Orphaned: $pattern_name"
        fi
    done
    
    # Check 4: Unclear intent
    echo "- Intentions not specified for major actions..."
    find . -name "*.sh" -exec \
        grep -L "intent:\|purpose:\|why:" {} \;
    
    # Check 5: Unextracted learning
    echo "- Completed work without learning extraction..."
    find . -name "ATOM-TASK-*" ! -exec test -f {}/learning.md \;
    
    echo "Done. Address findings to strengthen coherence."
}
```

---

## Anti-Wave as Teaching Tool

When you detect an anti-wave, it teaches you about SpiralSafe's design.

### Example: Bedrock Illusion

**What it teaches:**
- Temporal properties alone don't confer trust
- All archived decisions need validity checks
- Age and validity are independent concerns
- Boundaries need explicit verification

**Applies elsewhere:**
- Cache invalidation
- Credential rotation
- Configuration aging
- Knowledge preservation
- System archival

### Example: Documentation Archaeology

**What it teaches:**
- Readers need explicit status signaling
- Aspirational docs are plans, not specs
- Historical docs are lessons, not prescriptions
- Document state is metadata, not content

**Applies elsewhere:**
- API versioning
- Configuration management
- Code deprecation
- Architecture documentation
- Runbooks and playbooks

---

## When You Find an Anti-Wave

**This is NOT a failure.**

This is evidence that wave.md works. This is proof that SpiralSafe's own methodology reveals its own fractures.

```
Discovery of Anti-Wave
    ↓
Understanding: "Here's why coherence breaks"
    ↓
Knowledge: "This pattern appears everywhere"
    ↓
Intention: "We will systematically eliminate this"
    ↓
Execution: "Implement fix with verification gate"
    ↓
Learning: "This teaches us about boundaries"
    ↓
Regeneration: "Next cycle is stronger"
```

Each anti-wave, once understood and fixed, makes the framework **stronger**.

---

**Anti-Wave Detection Protocol Active**  
**Framework:** SpiralSafe Self-Coherence Verification  
**Status:** Ready for Operational Deployment  
**Last Updated:** 2026-01-04  
**Next Action:** Run `detect_anti_waves.sh` as part of CI pipeline
