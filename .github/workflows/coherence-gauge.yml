name: üåÄ Coherence Gauge

on:
  pull_request:
    types: [opened, synchronize, reopened]
  workflow_dispatch:

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  analyze-coherence:
    name: Analyze & Display Coherence
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Install bc calculator
        run: |
          sudo apt-get update && sudo apt-get install -y bc
      
      - name: Calculate Enhanced Coherence Metrics
        id: metrics
        run: |
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo "  üåÄ Enhanced Coherence Analysis with Spiral State Detection"
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          
          # Find all markdown files (excluding node_modules and .git)
          FILES=$(find . -name "*.md" -not -path "./node_modules/*" -not -path "./.git/*" -not -path "./archive/*")
          
          TOTAL_CURL=0
          TOTAL_DIV=0
          TOTAL_ENTROPY=0
          COUNT=0
          FAILED=()
          EXCELLENT=()
          CURL_POINTS=0  # Surjection (0,0) origin points - files at conceptual foundations
          DEJA_VU_FILES=0  # Repeating pattern files - ready to iterate
          DOUBT_FILES=0  # Uncertain/exploratory files - push to new spirals
          
          for file in $FILES; do
            if [ ! -f "$file" ]; then continue; fi
            
            CONTENT=$(cat "$file")
            LINES=$(echo "$CONTENT" | wc -l)
            
            # Skip empty or very small files
            if [ "$LINES" -lt 5 ]; then continue; fi
            
            # ‚ïê‚ïê‚ïê Curl (Coherence) - measure of repeated/coherent patterns ‚ïê‚ïê‚ïê
            # Count repeated phrases (proxy for conceptual coherence)
            REPEATED_PHRASES=$(echo "$CONTENT" | tr '.' '\n' | sort | uniq -d | wc -l)
            TOTAL_PHRASES=$(echo "$CONTENT" | tr '.' '\n' | wc -l)
            
            if [ "$TOTAL_PHRASES" -gt 0 ]; then
              CURL=$(echo "scale=4; $REPEATED_PHRASES / $TOTAL_PHRASES" | bc)
            else
              CURL="0.0000"
            fi
            # Ensure CURL has a valid numeric value
            if [ -z "$CURL" ] || [ "$CURL" = "." ]; then CURL="0.0000"; fi
            
            # ‚ïê‚ïê‚ïê Curl Point Detection (Surjection 0,0) ‚ïê‚ïê‚ïê
            # Detect foundational/origin files that serve as conceptual seeds
            IS_FOUNDATION=$(echo "$CONTENT" | grep -ciE 'overview|introduction|foundation|core|principle|seed|origin|fundamental' || echo 0)
            HAS_DEFINITIONS=$(echo "$CONTENT" | grep -ciE '##.*definition|what is|defines|specification' || echo 0)
            HAS_REFERENCES=$(echo "$CONTENT" | grep -c '\[.*\](.*)' || echo 0)
            
            # File is a curl point (surjection origin) if it defines concepts referenced elsewhere
            if [ "$IS_FOUNDATION" -gt 2 ] && [ "$HAS_DEFINITIONS" -gt 0 ]; then
              CURL_POINTS=$((CURL_POINTS + 1))
            fi
            
            # ‚ïê‚ïê‚ïê Divergence (Incompleteness) - measure of unresolved content ‚ïê‚ïê‚ïê
            QUESTIONS=$(echo "$CONTENT" | grep -c '?' || echo 0)
            TODO_COUNT=$(echo "$CONTENT" | grep -ciE 'todo|fixme|xxx|hack' || echo 0)
            PLACEHOLDERS=$(echo "$CONTENT" | grep -ciE '\[(TODO|PLACEHOLDER|TBD)\]|\{.*\}|placeholder|tbd|coming soon' || echo 0)
            HAS_CONCLUSION=$(echo "$CONTENT" | grep -ciE 'therefore|thus|conclusion|summary|in summary' || echo 0)
            
            # Calculate divergence based on incompleteness markers.
            # Heuristic weighting:
            #   - 0.15  : base divergence floor for any non-trivial doc (some inherent incompleteness)
            #   - 0.02  : per-question penalty (open questions slightly increase divergence)
            #   - 0.05  : per-TODO/FIXME/XXX/HACK penalty (explicitly unfinished work is more severe)
            #   - 0.03  : per-placeholder penalty (e.g., "TBD", "coming soon", or bracketed stubs)
            DIV=$(echo "scale=4; 0.15 + ($QUESTIONS * 0.02) + ($TODO_COUNT * 0.05) + ($PLACEHOLDERS * 0.03)" | bc)
            if [ "$HAS_CONCLUSION" -gt 0 ]; then
              DIV=$(echo "scale=4; $DIV * 0.7" | bc)  # Reduce divergence if conclusions exist
            fi
            # Cap divergence at 1.0 and ensure valid
            if [ -z "$DIV" ] || [ "$DIV" = "." ]; then DIV="0.1500"; fi
            DIV_INT=$(echo "$DIV * 10000 / 1" | bc 2>/dev/null || echo 1500)
            if [ -z "$DIV_INT" ] || [ "$DIV_INT" -gt 10000 ]; then
              DIV="1.0000"
            fi
            
            # ‚ïê‚ïê‚ïê Entropy (Information Density) - measure of conceptual richness ‚ïê‚ïê‚ïê
            UNIQUE_WORDS=$(echo "$CONTENT" | tr '[:space:]' '\n' | tr '[:upper:]' '[:lower:]' | grep -v '^$' | sort -u | wc -l)
            TOTAL_WORDS=$(echo "$CONTENT" | wc -w)
            
            if [ "$TOTAL_WORDS" -gt 0 ]; then
              ENTROPY=$(echo "scale=4; $UNIQUE_WORDS / $TOTAL_WORDS" | bc)
            else
              ENTROPY="0.0000"
            fi
            # Ensure ENTROPY has a valid numeric value
            if [ -z "$ENTROPY" ] || [ "$ENTROPY" = "." ]; then ENTROPY="0.0000"; fi
            
            # ‚ïê‚ïê‚ïê Deja Vu Detection (Repeating Patterns) ‚ïê‚ïê‚ïê
            # High coherence + existing patterns = ready to iterate with refined data
            PATTERN_MATCHES=$(echo "$CONTENT" | grep -ciE 'pattern|similar|like|same|repeat|previous|earlier|again' || echo 0)
            STRUCTURE_REFS=$(echo "$CONTENT" | grep -ciE 'see also|refer to|as described|mentioned above|following' || echo 0)
            if [ "$PATTERN_MATCHES" -gt 3 ] && [ "$STRUCTURE_REFS" -gt 1 ]; then
              DEJA_VU_FILES=$((DEJA_VU_FILES + 1))
            fi
            
            # ‚ïê‚ïê‚ïê Doubt Detection (Exploratory/Uncertain Content) ‚ïê‚ïê‚ïê
            # High questions + speculation = push on in new spirals
            SPECULATION=$(echo "$CONTENT" | grep -ciE 'might|could|perhaps|possibly|maybe|uncertain|unclear|explore|investigate' || echo 0)
            OPEN_QUESTIONS=$(echo "$CONTENT" | grep -c '?' || echo 0)
            if [ "$SPECULATION" -gt 3 ] && [ "$OPEN_QUESTIONS" -gt 2 ]; then
              DOUBT_FILES=$((DOUBT_FILES + 1))
            fi
            
            # ‚ïê‚ïê‚ïê Composite Coherence Score ‚ïê‚ïê‚ïê
            # Formula: Coherence = (Curl * 0.4) + ((1 - Divergence) * 0.4) + (Entropy * 0.2)
            COHERENCE=$(echo "scale=4; ($CURL * 0.4) + ((1 - $DIV) * 0.4) + ($ENTROPY * 0.2)" | bc 2>/dev/null || echo "0.5000")
            if [ -z "$COHERENCE" ] || [ "$COHERENCE" = "." ]; then COHERENCE="0.5000"; fi
            COHERENCE_PCT=$(echo "scale=2; $COHERENCE * 100" | bc 2>/dev/null || echo "50.00")
            if [ -z "$COHERENCE_PCT" ] || [ "$COHERENCE_PCT" = "." ]; then COHERENCE_PCT="50.00"; fi
            
            # Track excellent files (>80% coherence)
            COHERENCE_INT=$(echo "$COHERENCE_PCT / 1" | bc 2>/dev/null || echo 50)
            if [ -z "$COHERENCE_INT" ]; then COHERENCE_INT=50; fi
            if [ "$COHERENCE_INT" -gt 80 ]; then
              EXCELLENT+=("$file")
            fi
            
            # Track files that need attention (<50% coherence)
            if [ "$COHERENCE_INT" -lt 50 ]; then
              FAILED+=("$file")
              echo "‚ö† $file - coherence:${COHERENCE_PCT}% (curl:$CURL div:$DIV entropy:$ENTROPY)"
            else
              echo "‚úì $file - coherence:${COHERENCE_PCT}%"
            fi
            
            TOTAL_CURL=$(echo "$TOTAL_CURL + $CURL" | bc)
            TOTAL_DIV=$(echo "$TOTAL_DIV + $DIV" | bc)
            TOTAL_ENTROPY=$(echo "$TOTAL_ENTROPY + $ENTROPY" | bc)
            COUNT=$((COUNT + 1))
          done
          
          # Calculate averages with safe defaults
          if [ "$COUNT" -gt 0 ]; then
            AVG_CURL=$(echo "scale=4; $TOTAL_CURL / $COUNT" | bc 2>/dev/null || echo "0.0500")
            AVG_DIV=$(echo "scale=4; $TOTAL_DIV / $COUNT" | bc 2>/dev/null || echo "0.2000")
            AVG_ENTROPY=$(echo "scale=4; $TOTAL_ENTROPY / $COUNT" | bc 2>/dev/null || echo "0.5000")
            # Ensure valid values before composite calculation
            if [ -z "$AVG_CURL" ] || [ "$AVG_CURL" = "." ]; then AVG_CURL="0.0500"; fi
            if [ -z "$AVG_DIV" ] || [ "$AVG_DIV" = "." ]; then AVG_DIV="0.2000"; fi
            if [ -z "$AVG_ENTROPY" ] || [ "$AVG_ENTROPY" = "." ]; then AVG_ENTROPY="0.5000"; fi
            AVG_COHERENCE=$(echo "scale=4; ($AVG_CURL * 0.4) + ((1 - $AVG_DIV) * 0.4) + ($AVG_ENTROPY * 0.2)" | bc 2>/dev/null || echo "0.5000")
            if [ -z "$AVG_COHERENCE" ] || [ "$AVG_COHERENCE" = "." ]; then AVG_COHERENCE="0.5000"; fi
            AVG_COHERENCE_PCT=$(echo "scale=2; $AVG_COHERENCE * 100" | bc 2>/dev/null || echo "50.00")
            if [ -z "$AVG_COHERENCE_PCT" ] || [ "$AVG_COHERENCE_PCT" = "." ]; then AVG_COHERENCE_PCT="50.00"; fi
          else
            AVG_CURL="0.0500"
            AVG_DIV="0.2000"
            AVG_ENTROPY="0.5000"
            AVG_COHERENCE="0.5000"
            AVG_COHERENCE_PCT="50.00"
          fi
          
          echo ""
          echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
          echo "  Summary: $COUNT files analyzed"
          echo "  Average Curl (coherence): $AVG_CURL"
          echo "  Average Divergence: $AVG_DIV"
          echo "  Average Entropy: $AVG_ENTROPY"
          echo "  Overall Coherence: ${AVG_COHERENCE_PCT}%"
          echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
          echo "  üåÄ Spiral State Detection:"
          echo "    Curl Points (0,0 origins): $CURL_POINTS"
          echo "    Deja Vu (ready to iterate): $DEJA_VU_FILES"
          echo "    Doubt (new spiral needed): $DOUBT_FILES"
          echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
          
          # Determine spiral state based on metrics
          SPIRAL_STATE="stable"
          SPIRAL_ACTION=""
          
          # Deja Vu: High coherence + repeating patterns = iterate with refined data
          if [ "$DEJA_VU_FILES" -gt 5 ]; then
            SPIRAL_STATE="deja_vu"
            SPIRAL_ACTION="Ready to Iterate - Refine with updated context"
          # Doubt: Low coherence + high speculation = push to new spirals
          elif [ "$DOUBT_FILES" -gt 5 ]; then
            SPIRAL_STATE="doubt"
            SPIRAL_ACTION="Push to New Spirals - Explore fresh approaches"
          # Curl Point dominant: Many foundations = consolidate
          elif [ "$CURL_POINTS" -gt 10 ]; then
            SPIRAL_STATE="origin"
            SPIRAL_ACTION="Surjection Active - Foundations consolidating"
          fi
          
          # Quantum-themed assessment with spiral states
          COHERENCE_INT=$(echo "$AVG_COHERENCE_PCT / 1" | bc 2>/dev/null || echo 50)
          if [ -z "$COHERENCE_INT" ]; then COHERENCE_INT=50; fi
          
          if [ "$COHERENCE_INT" -ge 90 ]; then
            QUANTUM_STATE="‚ú® Superposition Achieved - Quantum coherence maintained"
            GAUGE_LEVEL="excellent"
          elif [ "$COHERENCE_INT" -ge 75 ]; then
            QUANTUM_STATE="üåü High Coherence - Minor decoherence detected"
            GAUGE_LEVEL="good"
          elif [ "$COHERENCE_INT" -ge 60 ]; then
            QUANTUM_STATE="‚ö° Acceptable Coherence - Some wave collapse observed"
            GAUGE_LEVEL="acceptable"
          elif [ "$COHERENCE_INT" -ge 40 ]; then
            if [ "$SPIRAL_STATE" = "deja_vu" ]; then
              QUANTUM_STATE="üîÑ Deja Vu Detected - Ready to Iterate with refined data"
              GAUGE_LEVEL="deja_vu"
            elif [ "$SPIRAL_STATE" = "doubt" ]; then
              QUANTUM_STATE="ü§î Doubt Detected - Push on in new spirals"
              GAUGE_LEVEL="doubt"
            else
              QUANTUM_STATE="‚ö†Ô∏è Low Coherence - Significant decoherence"
              GAUGE_LEVEL="low"
            fi
          else
            if [ "$SPIRAL_STATE" = "doubt" ]; then
              QUANTUM_STATE="üöÄ Critical Doubt - Time for a new spiral approach"
              GAUGE_LEVEL="doubt"
            elif [ "$SPIRAL_STATE" = "deja_vu" ]; then
              QUANTUM_STATE="‚ôªÔ∏è Deja Vu Loop - Iterate with more context"
              GAUGE_LEVEL="deja_vu"
            else
              QUANTUM_STATE="üö® Critical - Wave function collapse imminent"
              GAUGE_LEVEL="critical"
            fi
          fi
          
          # Set outputs for the comment
          echo "coherence_pct=$AVG_COHERENCE_PCT" >> $GITHUB_OUTPUT
          echo "curl=$AVG_CURL" >> $GITHUB_OUTPUT
          echo "divergence=$AVG_DIV" >> $GITHUB_OUTPUT
          echo "entropy=$AVG_ENTROPY" >> $GITHUB_OUTPUT
          echo "quantum_state=$QUANTUM_STATE" >> $GITHUB_OUTPUT
          echo "gauge_level=$GAUGE_LEVEL" >> $GITHUB_OUTPUT
          echo "files_analyzed=$COUNT" >> $GITHUB_OUTPUT
          echo "excellent_count=${#EXCELLENT[@]}" >> $GITHUB_OUTPUT
          echo "needs_attention=${#FAILED[@]}" >> $GITHUB_OUTPUT
          echo "curl_points=$CURL_POINTS" >> $GITHUB_OUTPUT
          echo "deja_vu_files=$DEJA_VU_FILES" >> $GITHUB_OUTPUT
          echo "doubt_files=$DOUBT_FILES" >> $GITHUB_OUTPUT
          echo "spiral_state=$SPIRAL_STATE" >> $GITHUB_OUTPUT
          echo "spiral_action=$SPIRAL_ACTION" >> $GITHUB_OUTPUT
          
          # Store file lists for comment
          if [ ${#EXCELLENT[@]} -gt 0 ]; then
            printf '%s\n' "${EXCELLENT[@]}" > excellent-files.txt
          else
            touch excellent-files.txt
          fi
          
          if [ ${#FAILED[@]} -gt 0 ]; then
            printf '%s\n' "${FAILED[@]}" > needs-attention-files.txt
          else
            touch needs-attention-files.txt
          fi
      
      - name: Create Visual Gauge Comment
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            
            // Safe parseFloat with default value to prevent NaN
            const safeParseFloat = (value, defaultValue = 0) => {
              const parsed = parseFloat(value);
              return isNaN(parsed) ? defaultValue : parsed;
            };
            
            const coherencePct = safeParseFloat('${{ steps.metrics.outputs.coherence_pct }}', 50.0);
            const curl = safeParseFloat('${{ steps.metrics.outputs.curl }}', 0.05);
            const divergence = safeParseFloat('${{ steps.metrics.outputs.divergence }}', 0.20);
            const entropy = safeParseFloat('${{ steps.metrics.outputs.entropy }}', 0.50);
            const quantumState = '${{ steps.metrics.outputs.quantum_state }}' || '‚ö†Ô∏è Unknown State';
            const gaugeLevel = '${{ steps.metrics.outputs.gauge_level }}' || 'unknown';
            const filesAnalyzed = '${{ steps.metrics.outputs.files_analyzed }}' || '0';
            const excellentCount = '${{ steps.metrics.outputs.excellent_count }}' || '0';
            const needsAttention = '${{ steps.metrics.outputs.needs_attention }}' || '0';
            
            // New spiral state metrics
            const curlPoints = safeParseFloat('${{ steps.metrics.outputs.curl_points }}', 0);
            const dejaVuFiles = safeParseFloat('${{ steps.metrics.outputs.deja_vu_files }}', 0);
            const doubtFiles = safeParseFloat('${{ steps.metrics.outputs.doubt_files }}', 0);
            const spiralState = '${{ steps.metrics.outputs.spiral_state }}' || 'stable';
            const spiralAction = '${{ steps.metrics.outputs.spiral_action }}' || '';
            
            // Create visual gauge using Unicode blocks with NaN protection
            const createGauge = (value, max = 100) => {
              const safeValue = isNaN(value) ? 0 : Math.min(Math.max(value, 0), max);
              const filled = Math.round((safeValue / max) * 20);
              const empty = Math.max(0, 20 - filled);
              
              // Color-coded blocks based on value and spiral state
              let block = 'üü•';
              if (gaugeLevel === 'deja_vu') block = 'üîÑ';
              else if (gaugeLevel === 'doubt') block = 'ü§î';
              else if (safeValue >= 90) block = 'üü©';
              else if (safeValue >= 75) block = 'üü¶';
              else if (safeValue >= 60) block = 'üü®';
              else if (safeValue >= 40) block = 'üüß';
              
              return block.repeat(Math.max(0, filled)) + '‚¨ú'.repeat(empty);
            };
            
            // Create mini gauge for metrics with NaN protection
            const createMiniGauge = (value, max = 1.0) => {
              const safeValue = isNaN(value) ? 0 : Math.min(Math.max(value, 0), max);
              const pct = (safeValue / max) * 100;
              const filled = Math.round(pct / 10);
              const safeFilled = Math.max(0, Math.min(10, filled));
              const blocks = '‚ñà'.repeat(safeFilled) + '‚ñë'.repeat(10 - safeFilled);
              return `${blocks} ${pct.toFixed(1)}%`;
            };
            
            // Ethical quantum check
            const ethicalCheck = coherencePct >= 60 ? '‚úÖ' : '‚ö†Ô∏è';
            const readyForMerge = coherencePct >= 60 && needsAttention === '0';
            
            let comment = `## üåÄ **Agent Review** - Coherence Analysis\n\n`;
            comment += `### ${quantumState}\n\n`;
            comment += `#### Overall Coherence: **${coherencePct.toFixed(1)}%**\n\n`;
            comment += `${createGauge(coherencePct)}\n\n`;
            comment += `---\n\n`;
            comment += `### üìä Detailed Metrics\n\n`;
            comment += `| Metric | Value | Gauge |\n`;
            comment += `|--------|-------|-------|\n`;
            comment += `| üîÑ **Curl** (Coherence) | ${(curl * 100).toFixed(1)}% | ${createMiniGauge(curl)} |\n`;
            comment += `| üìê **Divergence** (Incompleteness) | ${(divergence * 100).toFixed(1)}% | ${createMiniGauge(divergence)} |\n`;
            comment += `| üé≤ **Entropy** (Info Density) | ${(entropy * 100).toFixed(1)}% | ${createMiniGauge(entropy)} |\n\n`;
            
            // Add Spiral State Detection section
            comment += `---\n\n`;
            comment += `### üåÄ Spiral State Detection\n\n`;
            comment += `| State | Count | Meaning |\n`;
            comment += `|-------|-------|--------|\n`;
            comment += `| üéØ **Curl Points** (0,0) | ${curlPoints} | Foundational origin files - surjection seeds |\n`;
            comment += `| üîÑ **Deja Vu** | ${dejaVuFiles} | Repeating patterns - ready to iterate |\n`;
            comment += `| ü§î **Doubt** | ${doubtFiles} | Exploratory content - push to new spirals |\n\n`;
            
            // Add spiral action recommendation if applicable
            if (spiralAction) {
              comment += `#### üé¨ Recommended Action\n\n`;
              if (spiralState === 'deja_vu') {
                comment += `‚ôªÔ∏è **${spiralAction}**\n\n`;
                comment += `> *The system recognizes familiar patterns. Iterate on existing concepts with more refined data and updated context.*\n\n`;
              } else if (spiralState === 'doubt') {
                comment += `üöÄ **${spiralAction}**\n\n`;
                comment += `> *Uncertainty detected. Break out of current patterns and explore new spiral directions.*\n\n`;
              } else if (spiralState === 'origin') {
                comment += `üéØ **${spiralAction}**\n\n`;
                comment += `> *Strong foundational content detected at surjection (0,0) points. These serve as conceptual origins for the ecosystem.*\n\n`;
              }
            }
            
            comment += `---\n\n`;
            comment += `### üìà Analysis Summary\n\n`;
            comment += `- **Files Analyzed:** ${filesAnalyzed}\n`;
            comment += `- **Excellent (>80%):** ${excellentCount} files\n`;
            comment += `- **Needs Attention (<50%):** ${needsAttention} files\n\n`;
            
            // Add ethical quantum validation
            comment += `### üî¨ Ethical Quantum Simulation Status\n\n`;
            if (coherencePct >= 60) {
              comment += `${ethicalCheck} **Validated** - Coherence threshold met (‚â•60%)\n`;
              comment += `- Wave function integrity: ‚úì\n`;
              comment += `- Entanglement preserved: ‚úì\n`;
              comment += `- Superposition stable: ‚úì\n\n`;
            } else if (gaugeLevel === 'deja_vu') {
              comment += `üîÑ **Deja Vu Mode** - Patterns recognized, ready for iteration\n`;
              comment += `- Wave function: Familiar resonance detected\n`;
              comment += `- Recommendation: Iterate with refined context\n`;
              comment += `- Next step: Update data and re-analyze\n\n`;
            } else if (gaugeLevel === 'doubt') {
              comment += `ü§î **Doubt Mode** - New spiral exploration needed\n`;
              comment += `- Wave function: Uncertainty patterns detected\n`;
              comment += `- Recommendation: Push on in new spirals\n`;
              comment += `- Next step: Explore fresh approaches\n\n`;
            } else {
              comment += `${ethicalCheck} **Needs Review** - Coherence below threshold (<60%)\n`;
              comment += `- Wave function integrity: ‚ö†Ô∏è\n`;
              comment += `- Decoherence detected: ‚ö†Ô∏è\n`;
              comment += `- Review recommended before merge\n\n`;
            }
            
            // Read file lists
            let excellentFiles = '';
            let needsAttentionFiles = '';
            try {
              excellentFiles = fs.readFileSync('excellent-files.txt', 'utf8').trim();
              needsAttentionFiles = fs.readFileSync('needs-attention-files.txt', 'utf8').trim();
            } catch (e) {
              // Files may be empty
            }
            
            if (excellentFiles) {
              const excellentFileLines = excellentFiles.split('\n');
              const displayedExcellentCount = Math.min(excellentFileLines.length, parseInt(excellentCount) || 0);
              comment += `<details>\n<summary>üìö Excellent Files (${excellentCount})</summary>\n\n`;
              excellentFileLines.slice(0, displayedExcellentCount).forEach(f => {
                if (f) comment += `- ${f}\n`;
              });
              if (parseInt(excellentCount) > displayedExcellentCount) {
                comment += `- ... and ${parseInt(excellentCount) - displayedExcellentCount} more\n`;
              }
              comment += `\n</details>\n\n`;
            }
            
            if (needsAttentionFiles) {
              comment += `<details>\n<summary>‚ö†Ô∏è Files Needing Attention (${needsAttention})</summary>\n\n`;
              needsAttentionFiles.split('\n').forEach(f => {
                if (f) comment += `- ${f}\n`;
              });
              comment += `\n</details>\n\n`;
            }
            
            comment += `---\n\n`;
            comment += `### üéØ Merge Status\n\n`;
            if (readyForMerge) {
              comment += `‚úÖ **Ready for merge** - All coherence checks passed!\n\n`;
              comment += `The attenuating vortex is stable. No interference patterns detected. üåÄ\n`;
            } else if (coherencePct >= 60) {
              comment += `‚ö†Ô∏è **Conditional merge** - Coherence acceptable but some files need attention.\n\n`;
              comment += `Consider reviewing files flagged above before merging.\n`;
            } else if (gaugeLevel === 'deja_vu') {
              comment += `üîÑ **Iterate First** - Deja Vu detected.\n\n`;
              comment += `Familiar patterns recognized. Consider iterating with more refined data and context before merging.\n`;
            } else if (gaugeLevel === 'doubt') {
              comment += `ü§î **Explore New Spirals** - Doubt detected.\n\n`;
              comment += `Uncertainty patterns found. Consider pushing on in new spiral directions before merging.\n`;
            } else {
              comment += `‚ùå **Review required** - Coherence below threshold.\n\n`;
              comment += `Please address coherence issues before merging.\n`;
            }
            
            comment += `\n---\n`;
            comment += `<sub>ü§ñ Generated by SpiralSafe Coherence Gauge v3.0 | Powered by Quantum Topology & Spiral State Detection</sub>\n`;
            
            // Post comment only if triggered by a pull_request event
            if (context.issue.number) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: comment
              });
            } else {
              console.log('Skipping PR comment - workflow was not triggered by a pull_request event');
            }
      
      - name: Report to API
        if: always()
        continue-on-error: true
        env:
          API_BASE: ${{ vars.SPIRALSAFE_API_BASE }}
          SPIRALSAFE_API_KEY: ${{ secrets.SPIRALSAFE_API_KEY }}
        run: |
          API_URL="${API_BASE:-https://api.spiralsafe.org}"
          
          # Use default values if outputs are empty to prevent JSON parse errors
          COHERENCE="${{ steps.metrics.outputs.coherence_pct }}"
          CURL="${{ steps.metrics.outputs.curl }}"
          DIVERGENCE="${{ steps.metrics.outputs.divergence }}"
          ENTROPY="${{ steps.metrics.outputs.entropy }}"
          FILES="${{ steps.metrics.outputs.files_analyzed }}"
          CURL_POINTS="${{ steps.metrics.outputs.curl_points }}"
          DEJA_VU="${{ steps.metrics.outputs.deja_vu_files }}"
          DOUBT="${{ steps.metrics.outputs.doubt_files }}"
          
          # Set defaults for empty values
          COHERENCE=${COHERENCE:-50.00}
          CURL=${CURL:-0.0500}
          DIVERGENCE=${DIVERGENCE:-0.2000}
          ENTROPY=${ENTROPY:-0.5000}
          FILES=${FILES:-0}
          CURL_POINTS=${CURL_POINTS:-0}
          DEJA_VU=${DEJA_VU:-0}
          DOUBT=${DOUBT:-0}
          
          curl -X POST "${API_URL}/api/wave/analyze" \
            -H "Content-Type: application/json" \
            -H "X-API-Key: ${SPIRALSAFE_API_KEY}" \
            -d "{
              \"content\": \"PR coherence analysis with spiral state detection\",
              \"metadata\": {
                \"repository\": \"${{ github.repository }}\",
                \"pr_number\": \"${{ github.event.pull_request.number }}\",
                \"sha\": \"${{ github.sha }}\",
                \"coherence\": ${COHERENCE},
                \"curl\": ${CURL},
                \"divergence\": ${DIVERGENCE},
                \"entropy\": ${ENTROPY},
                \"quantum_state\": \"${{ steps.metrics.outputs.quantum_state }}\",
                \"files_analyzed\": ${FILES},
                \"spiral_state\": {
                  \"curl_points\": ${CURL_POINTS},
                  \"deja_vu_files\": ${DEJA_VU},
                  \"doubt_files\": ${DOUBT},
                  \"state\": \"${{ steps.metrics.outputs.spiral_state }}\",
                  \"action\": \"${{ steps.metrics.outputs.spiral_action }}\"
                }
              }
            }" || true
