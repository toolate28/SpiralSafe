#!/usr/bin/env bash
#
# SpiralSafe CLI
# Cross-platform command interface for the coherence engine
#
# Usage:
#   spiralsafe <command> [options]
#
# Commands:
#   wave      Coherence analysis
#   bump      Routing and handoff
#   awi       Permission scaffolding
#   atom      Task orchestration
#   saif      Issue investigation
#   status    System health check
#
# H&&S: Structure-preserving operations across substrates

set -euo pipefail

# ═══════════════════════════════════════════════════════════════
# Configuration
# ═══════════════════════════════════════════════════════════════

SPIRALSAFE_API_BASE="${SPIRALSAFE_API_BASE:-https://api.spiralsafe.org}"
SPIRALSAFE_AWI_GRANT="${SPIRALSAFE_AWI_GRANT:-}"
SPIRALSAFE_LOCAL="${SPIRALSAFE_LOCAL:-false}"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
CYAN='\033[0;36m'
GRAY='\033[0;90m'
NC='\033[0m' # No Color

# ═══════════════════════════════════════════════════════════════
# Utilities
# ═══════════════════════════════════════════════════════════════

log_success() { echo -e "${GREEN}✓${NC} $*"; }
log_error() { echo -e "${RED}✗${NC} $*" >&2; }
log_warn() { echo -e "${YELLOW}⚠${NC} $*"; }
log_info() { echo -e "${CYAN}→${NC} $*"; }
log_dim() { echo -e "${GRAY}  $*${NC}"; }

api_call() {
    local method="$1"
    local endpoint="$2"
    local data="${3:-}"
    
    local args=(-s -X "$method" -H "Content-Type: application/json")
    [[ -n "$data" ]] && args+=(-d "$data")
    
    curl "${args[@]}" "${SPIRALSAFE_API_BASE}${endpoint}"
}

require_jq() {
    if ! command -v jq &> /dev/null; then
        log_error "jq is required but not installed"
        exit 1
    fi
}

# ═══════════════════════════════════════════════════════════════
# Wave Commands
# ═══════════════════════════════════════════════════════════════

cmd_wave() {
    local subcommand="${1:-analyze}"
    shift || true
    
    case "$subcommand" in
        analyze)
            wave_analyze "$@"
            ;;
        thresholds)
            wave_thresholds
            ;;
        *)
            echo "Usage: spiralsafe wave <analyze|thresholds> [options]"
            echo ""
            echo "Commands:"
            echo "  analyze [path|--content 'text']  Analyze coherence"
            echo "  thresholds                       Show threshold values"
            ;;
    esac
}

wave_analyze() {
    require_jq
    local content=""
    local path=""
    local local_mode="$SPIRALSAFE_LOCAL"
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --content|-c) content="$2"; shift 2 ;;
            --local|-l) local_mode=true; shift ;;
            *) path="$1"; shift ;;
        esac
    done
    
    if [[ -n "$path" ]]; then
        if [[ -d "$path" ]]; then
            # Analyze directory
            find "$path" -type f \( -name "*.md" -o -name "*.txt" -o -name "*.yaml" -o -name "*.yml" \) | while read -r file; do
                content=$(cat "$file")
                analyze_content "$file" "$content" "$local_mode"
            done
        elif [[ -f "$path" ]]; then
            content=$(cat "$path")
            analyze_content "$path" "$content" "$local_mode"
        else
            log_error "Path not found: $path"
            exit 1
        fi
    elif [[ -n "$content" ]]; then
        analyze_content "<direct>" "$content" "$local_mode"
    else
        # Read from stdin
        content=$(cat)
        analyze_content "<stdin>" "$content" "$local_mode"
    fi
}

analyze_content() {
    local source="$1"
    local content="$2"
    local local_mode="$3"
    
    if [[ "$local_mode" == "true" ]]; then
        # Simplified local analysis
        local paragraphs
        paragraphs=$(echo "$content" | awk 'BEGIN{RS="\n\n+"} {print}' | wc -l)
        local questions
        questions=$(echo "$content" | grep -o '?' | wc -l)
        
        # Very simplified metrics
        local curl=0.1
        local divergence
        divergence=$(echo "scale=2; 0.2 + ($questions * 0.05)" | bc)
        local coherent="true"
        
        if (( $(echo "$divergence > 0.6" | bc -l) )); then
            coherent="false"
        fi
        
        printf "%-40s curl:%.2f div:%.2f %s\n" "$source" "$curl" "$divergence" \
            "$([ "$coherent" == "true" ] && echo -e "${GREEN}✓${NC}" || echo -e "${YELLOW}⚠${NC}")"
    else
        # API call
        local response
        response=$(api_call POST "/api/wave/analyze" "{\"content\": $(echo "$content" | jq -Rs .)}")
        
        local curl div potential coherent
        curl=$(echo "$response" | jq -r '.curl')
        div=$(echo "$response" | jq -r '.divergence')
        potential=$(echo "$response" | jq -r '.potential')
        coherent=$(echo "$response" | jq -r '.coherent')
        
        printf "%-40s curl:%.2f div:%.2f pot:%.2f %s\n" "$source" "$curl" "$div" "$potential" \
            "$([ "$coherent" == "true" ] && echo -e "${GREEN}✓${NC}" || echo -e "${YELLOW}⚠${NC}")"
    fi
}

wave_thresholds() {
    require_jq
    local response
    response=$(api_call GET "/api/wave/thresholds")
    echo "$response" | jq .
}

# ═══════════════════════════════════════════════════════════════
# Bump Commands
# ═══════════════════════════════════════════════════════════════

cmd_bump() {
    local subcommand="${1:-}"
    shift || true
    
    case "$subcommand" in
        WAVE|PASS|PING|SYNC|BLOCK)
            bump_create "$subcommand" "$@"
            ;;
        list|pending)
            bump_list
            ;;
        resolve)
            bump_resolve "$@"
            ;;
        *)
            echo "Usage: spiralsafe bump <WAVE|PASS|PING|SYNC|BLOCK|list|resolve> [options]"
            echo ""
            echo "Create bump:"
            echo "  spiralsafe bump WAVE --to copilot --state 'PR ready'"
            echo ""
            echo "List pending:"
            echo "  spiralsafe bump list"
            echo ""
            echo "Resolve:"
            echo "  spiralsafe bump resolve <id>"
            ;;
    esac
}

bump_create() {
    require_jq
    local type="$1"
    shift
    
    local to="unknown"
    local state="pending"
    local from="cli"
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --to|-t) to="$2"; shift 2 ;;
            --state|-s) state="$2"; shift 2 ;;
            --from|-f) from="$2"; shift 2 ;;
            *) shift ;;
        esac
    done
    
    local data
    data=$(jq -n \
        --arg type "$type" \
        --arg to "$to" \
        --arg state "$state" \
        --arg from "$from" \
        '{type: $type, to: $to, state: $state, from: $from}')
    
    local response
    response=$(api_call POST "/api/bump/create" "$data")
    
    if echo "$response" | jq -e '.id' > /dev/null 2>&1; then
        local id
        id=$(echo "$response" | jq -r '.id')
        log_success "Bump created: $id"
        log_info "H&&S:$type → $to"
        log_dim "State: $state"
        
        # Copy marker to clipboard if available
        local marker="H&&S:$type"
        if command -v pbcopy &> /dev/null; then
            echo -n "$marker" | pbcopy
            log_dim "Marker copied to clipboard: $marker"
        elif command -v xclip &> /dev/null; then
            echo -n "$marker" | xclip -selection clipboard
            log_dim "Marker copied to clipboard: $marker"
        fi
    else
        log_error "Failed to create bump"
        echo "$response" | jq .
    fi
}

bump_list() {
    require_jq
    local response
    response=$(api_call GET "/api/bump/pending")
    
    if [[ "$(echo "$response" | jq 'length')" == "0" ]]; then
        log_success "No pending bumps"
        return
    fi
    
    echo -e "${CYAN}Pending Bumps:${NC}"
    echo "$response" | jq -r '.[] | "  [\(.type)] \(.from_agent) → \(.to_agent)\n    State: \(.state)\n    ID: \(.id)"'
}

bump_resolve() {
    local id="${1:-}"
    
    if [[ -z "$id" ]]; then
        log_error "Usage: spiralsafe bump resolve <id>"
        exit 1
    fi
    
    local response
    response=$(api_call PUT "/api/bump/resolve/$id")
    
    if echo "$response" | jq -e '.resolved' > /dev/null 2>&1; then
        log_success "Bump resolved: $id"
    else
        log_error "Failed to resolve bump"
    fi
}

# ═══════════════════════════════════════════════════════════════
# AWI Commands
# ═══════════════════════════════════════════════════════════════

cmd_awi() {
    local subcommand="${1:-}"
    shift || true
    
    case "$subcommand" in
        request|grant)
            awi_request "$@"
            ;;
        verify|test)
            awi_verify "$@"
            ;;
        audit)
            awi_audit "$@"
            ;;
        *)
            echo "Usage: spiralsafe awi <request|verify|audit> [options]"
            echo ""
            echo "Request permission:"
            echo "  spiralsafe awi request --intent 'Deploy update' --resources 'docs/*' --actions 'modify' --level 2"
            echo ""
            echo "Verify action:"
            echo "  spiralsafe awi verify --action 'modify:README.md'"
            echo ""
            echo "View audit trail:"
            echo "  spiralsafe awi audit <grant-id>"
            ;;
    esac
}

awi_request() {
    require_jq
    local intent=""
    local resources=()
    local actions=()
    local level=1
    local ttl=3600
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --intent|-i) intent="$2"; shift 2 ;;
            --resources|-r) IFS=',' read -ra resources <<< "$2"; shift 2 ;;
            --actions|-a) IFS=',' read -ra actions <<< "$2"; shift 2 ;;
            --level|-l) level="$2"; shift 2 ;;
            --ttl|-t) ttl="$2"; shift 2 ;;
            *) shift ;;
        esac
    done
    
    if [[ -z "$intent" ]]; then
        log_error "Intent is required"
        exit 1
    fi
    
    local data
    data=$(jq -n \
        --arg intent "$intent" \
        --argjson resources "$(printf '%s\n' "${resources[@]}" | jq -R . | jq -s .)" \
        --argjson actions "$(printf '%s\n' "${actions[@]}" | jq -R . | jq -s .)" \
        --argjson level "$level" \
        --argjson ttl "$ttl" \
        '{intent: $intent, scope: {resources: $resources, actions: $actions}, level: $level, ttl_seconds: $ttl}')
    
    local response
    response=$(api_call POST "/api/awi/request" "$data")
    
    if echo "$response" | jq -e '.id' > /dev/null 2>&1; then
        local id expires
        id=$(echo "$response" | jq -r '.id')
        expires=$(echo "$response" | jq -r '.expires_at')
        
        log_success "AWI Grant Created"
        log_info "ID: $id"
        log_dim "Intent: $intent"
        log_dim "Level: $level"
        log_dim "Expires: $expires"
        
        # Store for subsequent operations
        export SPIRALSAFE_AWI_GRANT="$id"
        echo ""
        log_dim "Grant ID stored in SPIRALSAFE_AWI_GRANT"
    else
        log_error "Failed to create AWI grant"
        echo "$response" | jq .
    fi
}

awi_verify() {
    require_jq
    local grant_id="${SPIRALSAFE_AWI_GRANT:-}"
    local action=""
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --grant|-g) grant_id="$2"; shift 2 ;;
            --action|-a) action="$2"; shift 2 ;;
            *) action="$1"; shift ;;
        esac
    done
    
    if [[ -z "$grant_id" ]]; then
        log_error "No grant ID provided or stored in SPIRALSAFE_AWI_GRANT"
        exit 1
    fi
    
    if [[ -z "$action" ]]; then
        log_error "Action is required"
        exit 1
    fi
    
    local data
    data=$(jq -n --arg grant_id "$grant_id" --arg action "$action" \
        '{grant_id: $grant_id, action: $action}')
    
    local response
    response=$(api_call POST "/api/awi/verify" "$data")
    
    if echo "$response" | jq -e '.valid == true' > /dev/null 2>&1; then
        log_success "Action permitted: $action"
    else
        log_error "Action denied: $action"
        exit 1
    fi
}

awi_audit() {
    require_jq
    local grant_id="${1:-$SPIRALSAFE_AWI_GRANT}"
    
    if [[ -z "$grant_id" ]]; then
        log_error "Grant ID required"
        exit 1
    fi
    
    local response
    response=$(api_call GET "/api/awi/audit/$grant_id")
    echo "$response" | jq .
}

# ═══════════════════════════════════════════════════════════════
# SPHINX Commands
# ═══════════════════════════════════════════════════════════════

cmd_sphinx() {
    local subcommand="${1:-}"
    shift || true
    
    case "$subcommand" in
        validate)
            sphinx_validate "$@"
            ;;
        gate)
            sphinx_gate "$@"
            ;;
        report)
            sphinx_report "$@"
            ;;
        *)
            echo "Usage: spiralsafe sphinx <validate|gate|report> [options]"
            echo ""
            echo "Commands:"
            echo "  validate <file>  Validate artifact through all SPHINX gates"
            echo "  gate <name> <file>  Validate a single gate"
            echo "  report <file>  Generate full gate report"
            echo ""
            echo "Options:"
            echo "  --threshold <N>  Set coherence threshold (default: 80)"
            echo "  --json          Output as JSON"
            echo ""
            ;;
    esac
}
# ATOM Commands - Trail of Decisions
# ═══════════════════════════════════════════════════════════════

cmd_atom() {
    local subcommand="${1:-help}"
    shift || true
    
    case "$subcommand" in
        log)
            atom_log "$@"
            ;;
        query)
            atom_query "$@"
            ;;
        chain)
            atom_chain "$@"
            ;;
        verify)
            atom_verify
            ;;
        export)
            atom_export "$@"
            ;;
        *)
            echo "Usage: spiralsafe atom <log|query|chain|verify|export> [options]"
            echo ""
            echo "Commands:"
            echo "  log <decision> <rationale> <outcome>  Log a decision"
            echo "  query [--actor <actor>] [--since <date>]  Query trail"
            echo "  chain <entry-id>                      Show decision chain"
            echo "  verify                                Verify trail integrity"
            echo "  export [--format <format>] [--since <date>]  Export trail"
            echo ""
            echo "Examples:"
            echo "  spiralsafe atom log \"Deploy to prod\" \"All tests pass\" \"Success\""
            echo "  spiralsafe atom query --actor claude --since 2026-01-19"
            echo "  spiralsafe atom verify"
            echo "  spiralsafe atom export --format markdown"
            ;;
    esac
}

sphinx_validate() {
    require_jq
    local file=""
    local threshold=80
    local output_json=false
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --threshold|-t) threshold="$2"; shift 2 ;;
            --json|-j) output_json=true; shift ;;
            *) file="$1"; shift ;;
        esac
    done
    
    if [[ -z "$file" ]]; then
        log_error "File path required"
        exit 1
    fi
    
    if [[ ! -f "$file" ]]; then
        log_error "File not found: $file"
        exit 1
    fi
    
    local content
    content=$(cat "$file")
    local filename
    filename=$(basename "$file")
    
    local data
    data=$(jq -n \
        --arg id "$(uuidgen 2>/dev/null || echo "file-$(date +%s)")" \
        --arg type "$(file -b --mime-type "$file" 2>/dev/null || echo 'text/plain')" \
        --arg content "$content" \
        --arg source "$file" \
        --arg author "$USER" \
        --argjson threshold "$threshold" \
        '{
            artifact: {
                id: $id,
                type: $type,
                content: $content,
                metadata: { intent: "Validate file", source_file: $source },
                source: $source,
                author: $author
            },
            options: { coherenceThreshold: $threshold }
        }')
    
    log_info "Validating $filename through SPHINX gates..."
    
    local response
    response=$(api_call POST "/api/sphinx/validate" "$data")
    
    if [[ "$output_json" == "true" ]]; then
        echo "$response" | jq .
    else
        local overall_passed
        overall_passed=$(echo "$response" | jq -r '.overallPassed')
        
        echo ""
        echo -e "${CYAN}═════════════════════════════════════════${NC}"
        echo -e "${CYAN}  SPHINX Gate Validation Report${NC}"
        echo -e "${CYAN}═════════════════════════════════════════${NC}"
        echo ""
        echo -e "  File: ${YELLOW}$filename${NC}"
        echo ""
        
        for gate in origin intent coherence identity passage; do
            local gate_result
            gate_result=$(echo "$response" | jq -r ".gates.$gate")
            
            if [[ "$gate_result" == "null" ]]; then
                echo -e "  $gate: ${GRAY}SKIPPED${NC}"
            else
                local passed
                passed=$(echo "$gate_result" | jq -r '.passed')
                if [[ "$passed" == "true" ]]; then
                    echo -e "  $gate: ${GREEN}✓ PASS${NC}"
                else
                    echo -e "  $gate: ${RED}✗ FAIL${NC}"
                    local reasoning
                    reasoning=$(echo "$gate_result" | jq -r '.reasoning')
                    echo -e "    ${GRAY}$reasoning${NC}"
                fi
            fi
        done
        
        echo ""
        echo -e "${CYAN}─────────────────────────────────────────${NC}"
        if [[ "$overall_passed" == "true" ]]; then
            echo -e "  Overall: ${GREEN}✓ ALL GATES PASSED${NC}"
        else
            local failed_at
            failed_at=$(echo "$response" | jq -r '.failedAt // "unknown"')
            echo -e "  Overall: ${RED}✗ FAILED AT: $failed_at${NC}"
        fi
        echo -e "${CYAN}═════════════════════════════════════════${NC}"
        echo ""
    fi
}

sphinx_gate() {
    require_jq
    local gate_name=""
    local file=""
    local threshold=80
    
    gate_name="${1:-}"
    shift || true
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --threshold|-t) threshold="$2"; shift 2 ;;
            *) file="$1"; shift ;;
        esac
    done
    
    if [[ -z "$gate_name" ]] || [[ -z "$file" ]]; then
        log_error "Usage: spiralsafe sphinx gate <gate-name> <file>"
        exit 1
    fi
    
    if [[ ! -f "$file" ]]; then
        log_error "File not found: $file"
        exit 1
    fi
    
    local content
    content=$(cat "$file")
    
    local data
    data=$(jq -n \
        --arg gate "$gate_name" \
        --arg id "$(uuidgen 2>/dev/null || echo "file-$(date +%s)")" \
        --arg type "text" \
        --arg content "$content" \
        --arg source "$file" \
        --argjson threshold "$threshold" \
        '{
            gateName: $gate,
            artifact: {
                id: $id,
                type: $type,
                content: $content,
                metadata: { intent: "Gate validation" },
                source: $source
            },
            options: { coherenceThreshold: $threshold }
        }')
    
    local response
    response=$(api_call POST "/api/sphinx/gate" "$data")
    
    local passed
    passed=$(echo "$response" | jq -r '.passed')
    local reasoning
    reasoning=$(echo "$response" | jq -r '.reasoning')
    
    echo ""
    echo -e "${CYAN}Gate: $gate_name${NC}"
    if [[ "$passed" == "true" ]]; then
        log_success "PASS"
    else
        log_error "FAIL"
    fi
    echo -e "${GRAY}$reasoning${NC}"
    echo ""
}

sphinx_report() {
    local file="${1:-}"
    
    if [[ -z "$file" ]]; then
        log_error "File path required"
        exit 1
    fi
    
    # Full report is same as validate but with more detail
    sphinx_validate --json "$file" | jq .
}
atom_log() {
    require_jq
    local decision="${1:-}"
    local rationale="${2:-}"
    local outcome="${3:-}"
    
    if [[ -z "$decision" ]] || [[ -z "$rationale" ]] || [[ -z "$outcome" ]]; then
        log_error "Usage: spiralsafe atom log <decision> <rationale> <outcome>"
        echo ""
        echo "Options:"
        echo "  --actor <actor>              Actor making the decision (default: cli)"
        echo "  --coherence <score>          Coherence score (0-1)"
        echo "  --parent <entry-id>          Parent entry ID"
        echo "  --vortex <state>             Vortex state"
        exit 1
    fi
    
    local actor="cli"
    local coherence=""
    local parent=""
    local vortex=""
    
    shift 3
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --actor|-a) actor="$2"; shift 2 ;;
            --coherence|-c) coherence="$2"; shift 2 ;;
            --parent|-p) parent="$2"; shift 2 ;;
            --vortex|-v) vortex="$2"; shift 2 ;;
            *) shift ;;
        esac
    done
    
    local data
    if [[ -n "$coherence" ]]; then
        data=$(jq -n \
            --arg actor "$actor" \
            --arg decision "$decision" \
            --arg rationale "$rationale" \
            --arg outcome "$outcome" \
            --arg coherence "$coherence" \
            --arg parent "$parent" \
            --arg vortex "$vortex" \
            '{actor: $actor, decision: $decision, rationale: $rationale, outcome: $outcome, coherenceScore: ($coherence | tonumber), parentEntry: (if $parent == "" then null else $parent end), vortexState: (if $vortex == "" then null else $vortex end), context: {}}')
    else
        data=$(jq -n \
            --arg actor "$actor" \
            --arg decision "$decision" \
            --arg rationale "$rationale" \
            --arg outcome "$outcome" \
            --arg parent "$parent" \
            --arg vortex "$vortex" \
            '{actor: $actor, decision: $decision, rationale: $rationale, outcome: $outcome, parentEntry: (if $parent == "" then null else $parent end), vortexState: (if $vortex == "" then null else $vortex end), context: {}}')
    fi
    
    local response
    response=$(api_call POST "/api/atom/trail/log" "$data")
    
    if echo "$response" | jq -e '.success' > /dev/null 2>&1; then
        local id
        id=$(echo "$response" | jq -r '.id')
        log_success "ATOM entry logged: $id"
        log_dim "Decision: $decision"
        log_dim "Outcome: $outcome"
    else
        log_error "Failed to log ATOM entry"
        echo "$response" | jq .
    fi
}

atom_query() {
    require_jq
    
    local actor=""
    local since=""
    local until=""
    local decision=""
    local outcome=""
    local limit="50"
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --actor|-a) actor="$2"; shift 2 ;;
            --since|-s) since="$2"; shift 2 ;;
            --until|-u) until="$2"; shift 2 ;;
            --decision|-d) decision="$2"; shift 2 ;;
            --outcome|-o) outcome="$2"; shift 2 ;;
            --limit|-l) limit="$2"; shift 2 ;;
            *) shift ;;
        esac
    done
    
    local data
    data=$(jq -n \
        --arg actor "$actor" \
        --arg since "$since" \
        --arg until "$until" \
        --arg decision "$decision" \
        --arg outcome "$outcome" \
        --arg limit "$limit" \
        '{actor: (if $actor == "" then null else $actor end), since: (if $since == "" then null else $since end), until: (if $until == "" then null else $until end), decision: (if $decision == "" then null else $decision end), outcome: (if $outcome == "" then null else $outcome end), limit: ($limit | tonumber)}')
    
    local response
    response=$(api_call POST "/api/atom/trail/query" "$data")
    
    local count
    count=$(echo "$response" | jq -r '.count')
    
    if [[ "$count" == "0" ]]; then
        log_success "No entries found"
        return
    fi
    
    echo -e "${CYAN}ATOM Trail Entries (${count}):${NC}"
    echo "$response" | jq -r '.entries[] | "  [\(.timestamp)] \(.actor)\n    Decision: \(.decision)\n    Outcome: \(.outcome)\n    ID: \(.id)\n"'
}

atom_chain() {
    require_jq
    local entry_id="${1:-}"
    
    if [[ -z "$entry_id" ]]; then
        log_error "Usage: spiralsafe atom chain <entry-id>"
        exit 1
    fi
    
    local response
    response=$(api_call GET "/api/atom/trail/chain/$entry_id")
    
    if echo "$response" | jq -e '.entries' > /dev/null 2>&1; then
        local depth valid
        depth=$(echo "$response" | jq -r '.depth')
        valid=$(echo "$response" | jq -r '.integrityValid')
        
        echo -e "${CYAN}Decision Chain (depth: $depth):${NC}"
        
        if [[ "$valid" == "true" ]]; then
            log_success "Chain integrity: VALID"
        else
            log_error "Chain integrity: INVALID"
        fi
        
        echo ""
        echo "$response" | jq -r '.entries[] | "  [\(.timestamp)] \(.actor)\n    Decision: \(.decision)\n    Outcome: \(.outcome)\n    ID: \(.id)\n"'
    else
        log_error "Failed to retrieve chain"
        echo "$response" | jq .
    fi
}

atom_verify() {
    require_jq
    
    log_info "Verifying ATOM trail integrity..."
    
    local response
    response=$(api_call GET "/api/atom/trail/verify")
    
    if echo "$response" | jq -e '.valid' > /dev/null 2>&1; then
        local valid total broken tampered
        valid=$(echo "$response" | jq -r '.valid')
        total=$(echo "$response" | jq -r '.totalEntries')
        broken=$(echo "$response" | jq -r '.brokenChains')
        tampered=$(echo "$response" | jq -r '.tamperedEntries | length')
        
        if [[ "$valid" == "true" ]]; then
            log_success "Trail integrity: VALID"
        else
            log_error "Trail integrity: INVALID"
        fi
        
        echo ""
        echo "  Total entries: $total"
        echo "  Broken chains: $broken"
        echo "  Tampered entries: $tampered"
        
        if [[ "$tampered" -gt 0 ]]; then
            echo ""
            echo -e "${YELLOW}Tampered entries:${NC}"
            echo "$response" | jq -r '.tamperedEntries[]'
        fi
        
        if [[ "$(echo "$response" | jq -r '.details | length')" -gt 0 ]]; then
            echo ""
            echo -e "${YELLOW}Details:${NC}"
            echo "$response" | jq -r '.details[] | "  - \(.)"'
        fi
    else
        log_error "Failed to verify trail"
        echo "$response" | jq .
    fi
}

atom_export() {
    require_jq
    
    local format="markdown"
    local since=""
    local actor=""
    local limit="1000"
    local output=""
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --format|-f) format="$2"; shift 2 ;;
            --since|-s) since="$2"; shift 2 ;;
            --actor|-a) actor="$2"; shift 2 ;;
            --limit|-l) limit="$2"; shift 2 ;;
            --output|-o) output="$2"; shift 2 ;;
            *) shift ;;
        esac
    done
    
    if [[ ! "$format" =~ ^(markdown|json|csv)$ ]]; then
        log_error "Format must be: markdown, json, or csv"
        exit 1
    fi
    
    local filter_data
    filter_data=$(jq -n \
        --arg actor "$actor" \
        --arg since "$since" \
        --arg limit "$limit" \
        '{actor: (if $actor == "" then null else $actor end), since: (if $since == "" then null else $since end), limit: ($limit | tonumber)}')
    
    local data
    data=$(jq -n \
        --arg format "$format" \
        --argjson filter "$filter_data" \
        '{format: $format, filter: $filter}')
    
    log_info "Exporting ATOM trail to $format..."
    
    local response
    response=$(curl -s -X POST \
        -H "Content-Type: application/json" \
        -d "$data" \
        "${SPIRALSAFE_API_BASE}/api/atom/trail/export")
    
    if [[ -n "$output" ]]; then
        echo "$response" > "$output"
        log_success "Exported to: $output"
    else
        echo "$response"
    fi
}

# ═══════════════════════════════════════════════════════════════
# Status Command
# ═══════════════════════════════════════════════════════════════

cmd_status() {
    echo ""
    echo -e "${CYAN}SpiralSafe Operations Status${NC}"
    echo "════════════════════════════════════════"
    
    echo ""
    echo -e "${YELLOW}  Local Configuration:${NC}"
    echo -e "    API Base: $SPIRALSAFE_API_BASE"
    echo -e "    AWI Grant: ${SPIRALSAFE_AWI_GRANT:-${GRAY}(none)${NC}}"
    echo -e "    Local Mode: $SPIRALSAFE_LOCAL"
    
    echo ""
    echo -e "${YELLOW}  API Status:${NC}"
    
    local response
    if response=$(curl -s --connect-timeout 5 "${SPIRALSAFE_API_BASE}/api/health"); then
        if command -v jq &> /dev/null; then
            local status d1 kv r2
            status=$(echo "$response" | jq -r '.status')
            d1=$(echo "$response" | jq -r '.checks.d1')
            kv=$(echo "$response" | jq -r '.checks.kv')
            r2=$(echo "$response" | jq -r '.checks.r2')
            
            echo -e "    Status: $([ "$status" == "healthy" ] && echo -e "${GREEN}$status${NC}" || echo -e "${YELLOW}$status${NC}")"
            echo -e "    D1: $([ "$d1" == "true" ] && echo -e "${GREEN}✓${NC}" || echo -e "${RED}✗${NC}")"
            echo -e "    KV: $([ "$kv" == "true" ] && echo -e "${GREEN}✓${NC}" || echo -e "${RED}✗${NC}")"
            echo -e "    R2: $([ "$r2" == "true" ] && echo -e "${GREEN}✓${NC}" || echo -e "${RED}✗${NC}")"
        else
            echo "    Response: $response"
        fi
    else
        echo -e "    Status: ${RED}UNREACHABLE${NC}"
        echo -e "    ${GRAY}(Using local mode for wave analysis)${NC}"
    fi
    
    echo ""
}

# ═══════════════════════════════════════════════════════════════
# Help
# ═══════════════════════════════════════════════════════════════

cmd_help() {
    cat << 'EOF'
SpiralSafe CLI - Coherence Engine Operations

Usage:
  spiralsafe <command> [subcommand] [options]

Commands:
  wave      Coherence analysis (wave.md protocol)
  bump      Routing and handoff (bump.md protocol)
  awi       Permission scaffolding (AWI protocol)
  sphinx    Security gate validation (SPHINX protocol)
  atom      Task orchestration (ATOM methodology)
  saif      Issue investigation (SAIF methodology)
  status    System health check
  help      Show this help

Examples:
  # Analyze document coherence
  spiralsafe wave analyze ./docs

  # Create a handoff to Copilot
  spiralsafe bump WAVE --to copilot --state "PR ready"

  # Request deployment permission
  spiralsafe awi request --intent "Deploy docs" --resources "docs/*" --actions "modify" --level 2

  # Validate artifact through SPHINX gates
  spiralsafe sphinx validate ./artifact.md --threshold 80

  # Check system status
  spiralsafe status

Environment Variables:
  SPIRALSAFE_API_BASE    API endpoint (default: https://api.spiralsafe.org)
  SPIRALSAFE_AWI_GRANT   Current AWI grant ID
  SPIRALSAFE_LOCAL       Use local analysis mode (true/false)

H&&S: Structure-preserving operations across substrates
EOF
}

# ═══════════════════════════════════════════════════════════════
# Main Entry Point
# ═══════════════════════════════════════════════════════════════

main() {
    local command="${1:-help}"
    shift || true
    
    case "$command" in
        wave)     cmd_wave "$@" ;;
        bump)     cmd_bump "$@" ;;
        awi)      cmd_awi "$@" ;;
        sphinx)   cmd_sphinx "$@" ;;
        atom)     echo "ATOM commands: Use PowerShell module or API directly" ;;
        atom)     cmd_atom "$@" ;;
        saif)     echo "SAIF commands: Use PowerShell module or API directly" ;;
        status)   cmd_status ;;
        help|-h|--help) cmd_help ;;
        *)
            log_error "Unknown command: $command"
            cmd_help
            exit 1
            ;;
    esac
}

main "$@"
